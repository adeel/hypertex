#!/usr/bin/env python

import sys
import os.path
from functools import reduce
from lxml import etree
from jinja2 import Environment, FileSystemLoader

_par_tags = ["par"]
_block_tags = ["p", "def", "rmk", "lem", "prp", "thm", "cor", "prf", "exm"]
_inline_tags = ["b", "i", "u", "d", "cite", "term"]

def register_error(message):
  print "Error: %s" % message

def _dict_merge(d, e):
  return dict(list(d.items()) + list(e.items()))

def _register_macros_from_file(macros, fname):
  if not os.path.isfile(fname):
    register_error("The macro file %s was not found and will not be loaded." % fname)
    return macros
  try:
    src = open(fname, "r").read()
  except IOError:
    register_error("The macro file %s could not be read and will not be loaded." % fname)
    return macros
  root = etree.fromstring(src)
  return _dict_merge(macros, dict([(x.attrib.get("name"), x.attrib.get("value"))
    for x in root.findall("macro")]))

def _parse_head(head):
  title = head.find("title")
  author = head.find("author")
  macros = dict([(x.attrib.get("name"), x.attrib.get("value"))
    for x in head.findall("macro")])
  macro_files = [x.attrib.get("src", "") for x in head.findall("macros")]
  macros = reduce(_register_macros_from_file, macro_files, macros)

  return {"title":  title.text if title is not None else "",
          "author": author.text if author is not None else "",
          "macros": macros}

def _parse_inline_tag(element):
  "Return the type of an inline tag (e.g. b => bold)."

  if element.tag == "b":
    return {"type": "bold"}
  elif element.tag == "i":
    return {"type": "italic"}
  elif element.tag == "u":
    return {"type": "underline"}
  elif element.tag == "d":
    return {"type": "definition"}
  elif element.tag == "cite":
    return {"type": "citation",
      "ref": element.attrib.get("ref"),
      "tag": element.attrib.get("tag")}
  elif element.tag == "term":
    return {"type": "term",
      "tag": element.attrib.get("tag")}

def _parse_node(element):
  """
  Parse a node (block tag or inline tag).
  Block tags are def, thm, prp, lem, cor, rmk, exm, prf.
  Inline tags are b, i, u, d, cite, term.
  """

  content = (([element.text] if element.text else [])
    + sum([[_parse_node(child), child.tail or ""] for child in element], []))
  if element.tag in _par_tags:
    return {"content": content}
  elif element.tag in _block_tags:
    return {"type": element.tag, "content": content}
  elif element.tag in _inline_tags:
    return _dict_merge(_parse_inline_tag(element), {"content": content})
  return {"content": content}

def _parse_body_pars(pars, element):
  if element.tag in _par_tags:
    return pars + [{
      "type":    element.tag,
      "content": [_parse_node(element)],
      "tags":    element.attrib.get("tag", "").split(";")}]
  return pars

def _parse_body(body):
  return {"body": {"pars": reduce(_parse_body_pars, body, [])}}

def _parse_first_gen(parsed, element):
  if element.tag == "head":
    return _dict_merge(parsed, _parse_head(element))
  if element.tag == "body":
    return _dict_merge(parsed, _parse_body(element))
  return parsed

def parse_texml(input):
  root = etree.fromstring(input)
  return reduce(_parse_first_gen, root, {})

def _render_content_to_html(node):
  if type(node) is str:
    return node
  content = node.get("content", "")
  if type(content) is list:
    content = "".join(_render_node_to_html(n) for n in content)
  return content

def _render_citation_to_html(node):
  tag = node.get("tag", "")
  ref = node.get("ref", "")
  url = ""
  text = _render_content_to_html(node)
  if tag:
    tag_parts = tag.split("/")
    if len(tag_parts) == 0:
      url = "#"
    elif len(tag_parts) == 1:
      url = "#" + tag_parts[0]
    else:
      url = "%s.html#%s" % (tag_parts[0], tag_parts[1])
    if not text.strip():
      text = tag
  elif ref:
    url = "#%s" % ref
  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("citation.html")
  return template.render({
    "tag":  tag,
    "ref":  ref,
    "url":  url,
    "text": text})

def _render_term_to_html(node):
  tag = node.get("tag", "")
  text = _render_content_to_html(node)

  tag_parts = tag.split("/")
  url = ""
  if len(tag_parts) == 0:
    url = "#"
  elif len(tag_parts) == 1:
    url = "#" + tag_parts[0]
  else:
    url = "%s.html#%s" % (tag_parts[0], tag_parts[1])

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("term.html")
  return template.render({
    "tag":  tag,
    "url":  url,
    "text": text})

def _render_node_to_html(node):
  if type(node) is str:
    return node
  content = _render_content_to_html(node)
  if node.get("type") in _block_tags:
    tmpl_path = os.path.dirname(os.path.realpath(__file__))
    env = Environment(loader=FileSystemLoader(tmpl_path))
    template = env.get_template("block.html")
    return template.render({"block": _dict_merge(node, {"content": content})})
  if node.get("type") == "paragraph":
    return "<p>%s</p>" % content
  if node.get("type") == "bold":
    return "<b>%s</b>" % content
  if node.get("type") == "italic":
    return "<i>%s</i>" % content
  if node.get("type") == "definition":
    return "<span class=\"definition\">%s</span>" % content
  if node.get("type") == "citation":
    return _render_citation_to_html(node)
  if node.get("type") == "term":
    return _render_term_to_html(node)
  return content

def _render_par_to_html(par):
  return "".join(_render_node_to_html(n) for n in par.get("content"))

def _escape_macros(macros):
  return [(k, v.replace("\\", "\\\\")) for (k, v) in macros.items()]

def texml_to_html(input):
  parsed = parse_texml(input)

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("template.html")
  html = template.render({
    "title":   parsed["title"],
    "author":  parsed["author"],
    "macros":  _escape_macros(parsed["macros"]),
    "pars":   [_dict_merge(p, {"content": _render_par_to_html(p)}) for p in parsed["body"]["pars"]]})
  return html

def _render_content_to_tex(node):
  if type(node) is str:
    return node
  content = node.get("content", "")
  if type(content) is list:
    content = "".join(_render_node_to_tex(n) for n in content)
  return content

def _render_citation_to_tex(node):
  return _render_content_to_tex(node)

def _render_term_to_tex(node):
  return _render_content_to_tex(node)

def _render_node_to_tex(node):
  if type(node) is str:
    return node
  content = _render_content_to_tex(node)

  if node.get("type") in _block_tags:
    tmpl_path = os.path.dirname(os.path.realpath(__file__))
    env = Environment(loader=FileSystemLoader(tmpl_path))
    template = env.get_template("block.tex")
    return template.render({"block": _dict_merge(node, {"content": content})})
  if node.get("type") == "paragraph":
    return "%s\n" % content
  if node.get("type") == "bold":
    return "\\textbf{%s}" % content
  if node.get("type") == "italic":
    return "\\emph{%s}" % content
  if node.get("type") == "definition":
    return "\\emph{%s}" % content
  if node.get("type") == "citation":
    return _render_citation_to_tex(node)
  if node.get("type") == "term":
    return _render_term_to_tex(node)
  return content

def _render_par_to_tex(par):
  return "".join(_render_node_to_tex(n) for n in par.get("content"))

def texml_to_tex(input):
  parsed = parse_texml(input)

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("template.tex")
  tex = template.render({
    "title":   parsed["title"],
    "author":  parsed["author"],
    "macros":  parsed["macros"].items(),
    "pars":   [_dict_merge(p, {"content": _render_par_to_tex(p)}) for p in parsed["body"]["pars"]]})
  return tex

if __name__ == "__main__":
  if len(sys.argv) < 2:
    register_error("Please specify input texml file.")
    exit()

  if len(sys.argv) < 3:
    format = "html"
  elif "html" in sys.argv[1]:
    format = "html"
  elif "tex" in sys.argv[1]:
    format = "tex"
  else:
    register_error("I don\'t understand the format: %s" % format)
    exit()

  infile = sys.argv[-1]
  try:
    input = open(infile, "r").read()
  except IOError:
    register_error("Unable to open the file: %s" % infile)
    exit()

  if format == "html":
    html_file = os.path.splitext(infile)[0] + ".html"
    try:
      open(html_file, "w").write(texml_to_html(input))
      print("Created %s" % html_file)
    except IOError:
      register_error("Unable to write to file: %s" % html_file)

  if format == "tex":
    tex_file = os.path.splitext(infile)[0] + ".tex"
    try:
      open(tex_file, "w").write(texml_to_tex(input))
      print("Created %s" % tex_file)
    except IOError:
      register_error("Unable to write to file: %s" % tex_file)
