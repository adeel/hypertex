#!/usr/bin/env python

import sys
import os.path
from functools import reduce
from lxml import etree
from jinja2 import Environment, FileSystemLoader
from optparse import OptionParser

_par_tags = ["par"]
_block_tags = ["p", "def", "rmk", "lem", "prp", "thm", "cor", "prf", "exm"]
_inline_tags = ["b", "i", "u", "d", "cite", "term"]

def register_error(message):
  print "Error: %s" % message

def _dict_merge(d, e):
  return dict(list(d.items()) + list(e.items()))

def _register_macros_from_file(macros, fname):
  if not os.path.isfile(fname):
    register_error("The macro file %s was not found and will not be loaded." % fname)
    return macros
  try:
    src = open(fname, "r").read()
  except IOError:
    register_error("The macro file %s could not be read and will not be loaded." % fname)
    return macros
  root = etree.fromstring(src)
  return _dict_merge(macros, dict([(x.attrib.get("name"), x.attrib.get("value"))
    for x in root.findall("macro")]))

def _parse_head(head):
  title = head.find("title")
  author = head.find("author")
  macros = dict([(x.attrib.get("name"), x.attrib.get("value"))
    for x in head.findall("macro")])
  macro_files = [x.attrib.get("src", "") for x in head.findall("macros")]
  macros = reduce(_register_macros_from_file, macro_files, macros)

  return {"title":  title.text if title is not None else "",
          "author": author.text if author is not None else "",
          "macros": macros}

def _parse_inline_tag(element):
  "Return the type of an inline tag (e.g. b => bold)."

  if element.tag == "b":
    return {"type": "bold"}
  elif element.tag == "i":
    return {"type": "italic"}
  elif element.tag == "u":
    return {"type": "underline"}
  elif element.tag == "d":
    return {"type": "definition"}
  elif element.tag == "cite":
    return {"type": "citation",
      "ref": element.attrib.get("ref"),
      "tag": element.attrib.get("tag")}
  elif element.tag == "term":
    return {"type": "term",
      "tag": element.attrib.get("tag")}

def _parse_node(element):
  """
  Parse a node (block tag or inline tag).
  Block tags are def, thm, prp, lem, cor, rmk, exm, prf.
  Inline tags are b, i, u, d, cite, term.
  """

  content = (([element.text] if element.text else [])
    + sum([[_parse_node(child), child.tail or ""] for child in element], []))
  if element.tag in _par_tags:
    return {"content": content}
  elif element.tag in _block_tags:
    return {"type": element.tag, "content": content}
  elif element.tag in _inline_tags:
    return _dict_merge(_parse_inline_tag(element), {"content": content})
  return {"content": content}

def _parse_body_pars(pars, element):
  if element.tag in _par_tags:
    return pars + [{
      "type":    element.tag,
      "content": [_parse_node(element)],
      "tags":    element.attrib.get("tag", "").split(";")}]
  return pars

def _parse_body(body):
  return {"body": {"pars": reduce(_parse_body_pars, body, [])}}

def _parse_first_gen(parsed, element):
  if element.tag == "head":
    return _dict_merge(parsed, _parse_head(element))
  if element.tag == "body":
    return _dict_merge(parsed, _parse_body(element))
  return parsed

def parse_texml(input):
  root = etree.fromstring(input)
  return reduce(_parse_first_gen, root, {})

def _render_content_to_html(node, parsed):
  if type(node) is str:
    return node
  content = node.get("content", "")
  if type(content) is list:
    content = "".join(_render_node_to_html(n, parsed) for n in content)
  return content

def _parse_tag(tag):
  doc = ""
  partag = ""
  tag_parts = tag.split("/")
  if len(tag_parts) == 1:
    partag = tag_parts[0]
  else:
    doc = tag_parts[0]
    partag = tag_parts[1]
  return (doc, partag)

def _get_number_of_par(tag, doc, parsed):
  """
  Get the number of the par with tag `tag` in the document with name `doc`.
  Takes also the parameter `parsed`, which should be the result of parsing
  the current document, just in order to avoid re-parsing it.
  """
  if doc:
    src = open(doc + ".xml", "r").read()
    parsed = parse_texml(src)
  doc_tags = [p.get("tags", []) for p in parsed.get("body").get("pars")]
  for (n, ts) in enumerate(doc_tags):
    if tag in ts:
      return n + 1
  register_error("Unable to find tag %s in document '%s'" % (tag, doc))
  return 0

def _render_citation_to_html(node, parsed):
  tag = node.get("tag", "")
  ref = node.get("ref", "")
  url = ""
  num = 0
  doc = ""
  text = _render_content_to_html(node, parsed)
  if tag:
    (doc, partag) = _parse_tag(tag)
    num = _get_number_of_par(partag, doc, parsed)
    url = "#"
    if doc:
      url = "%s.html#%d" % (doc, num)
    else:
      url = "#%d" % num
  elif ref:
    # TODO
    url = "#%s" % ref

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("citation.html")
  return template.render({
    "tag":  tag,
    "doc":  doc,
    "num":  num,
    "ref":  ref,
    "url":  url,
    "text": text})

def _render_term_to_html(node, parsed):
  tag = node.get("tag", "")
  text = _render_content_to_html(node, parsed)

  tag_parts = tag.split("/")
  url = ""
  if len(tag_parts) == 0:
    url = "#"
  elif len(tag_parts) == 1:
    url = "#" + tag_parts[0]
  else:
    url = "%s.html#%s" % (tag_parts[0], tag_parts[1])

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("term.html")
  return template.render({
    "tag":  tag,
    "url":  url,
    "text": text})

def _render_node_to_html(node, parsed):
  if type(node) is str:
    return node
  content = _render_content_to_html(node, parsed)
  if node.get("type") in _block_tags:
    tmpl_path = os.path.dirname(os.path.realpath(__file__))
    env = Environment(loader=FileSystemLoader(tmpl_path))
    template = env.get_template("block.html")
    return template.render({"block": _dict_merge(node, {"content": content})})
  if node.get("type") == "paragraph":
    return "<p>%s</p>" % content
  if node.get("type") == "bold":
    return "<b>%s</b>" % content
  if node.get("type") == "italic":
    return "<i>%s</i>" % content
  if node.get("type") == "definition":
    return "<span class=\"definition\">%s</span>" % content
  if node.get("type") == "citation":
    return _render_citation_to_html(node, parsed)
  if node.get("type") == "term":
    return _render_term_to_html(node, parsed)
  return content

def _render_par_to_html(par, parsed):
  return "".join(_render_node_to_html(n, parsed) for n in par.get("content"))

def _escape_macros(macros):
  return [(k, v.replace("\\", "\\\\")) for (k, v) in macros.items()]

def texml_to_html(input):
  parsed = parse_texml(input)

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("template.html")
  pars = [_dict_merge(p, {"content": _render_par_to_html(p, parsed)})
    for p in parsed["body"]["pars"]]
  html = template.render({
    "title":   parsed["title"],
    "author":  parsed["author"],
    "macros":  _escape_macros(parsed["macros"]),
    "pars":    pars})
  return html

def _render_content_to_tex(node, parsed):
  if type(node) is str:
    return node
  content = node.get("content", "")
  if type(content) is list:
    content = "".join(_render_node_to_tex(n, parsed) for n in content)
  return content

def _render_citation_to_tex(node, parsed):
  tag = node.get("tag", "")
  ref = node.get("ref", "")
  url = ""
  num = 0
  doc = ""
  text = _render_content_to_html(node, parsed)
  if tag:
    (doc, partag) = _parse_tag(tag)
    num = _get_number_of_par(partag, doc, parsed)
    url = "#"
    if doc:
      url = "%s.pdf#%d" % (doc, num)
    else:
      url = "#%d" % num
  elif ref:
    # TODO
    url = "#%s" % ref

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("citation.tex")
  return template.render({
    "tag":  tag,
    "doc":  doc,
    "num":  str(num),
    "ref":  ref,
    "url":  url,
    "text": text})

def _render_term_to_tex(node, parsed):
  return _render_content_to_tex(node, parsed)

def _render_node_to_tex(node, parsed):
  if type(node) is str:
    return node
  content = _render_content_to_tex(node, parsed)

  if node.get("type") in _block_tags:
    tmpl_path = os.path.dirname(os.path.realpath(__file__))
    env = Environment(loader=FileSystemLoader(tmpl_path))
    template = env.get_template("block.tex")
    return template.render({"block": _dict_merge(node, {"content": content})})
  if node.get("type") == "paragraph":
    return "%s\n" % content
  if node.get("type") == "bold":
    return "\\textbf{%s}" % content
  if node.get("type") == "italic":
    return "\\emph{%s}" % content
  if node.get("type") == "definition":
    return "\\emph{%s}" % content
  if node.get("type") == "citation":
    return _render_citation_to_tex(node, parsed)
  if node.get("type") == "term":
    return _render_term_to_tex(node, parsed)
  return content

def _render_par_to_tex(par, parsed):
  return "".join(_render_node_to_tex(n, parsed) for n in par.get("content"))

def texml_to_tex(input):
  parsed = parse_texml(input)

  tmpl_path = os.path.dirname(os.path.realpath(__file__))
  env = Environment(loader=FileSystemLoader(tmpl_path))
  template = env.get_template("template.tex")
  tex = template.render({
    "title":   parsed["title"],
    "author":  parsed["author"],
    "macros":  parsed["macros"].items(),
    "pars":   [_dict_merge(p, {"content": _render_par_to_tex(p, parsed)}) for p in parsed["body"]["pars"]]})
  return tex

if __name__ == "__main__":
  parser = OptionParser()

  parser.add_option("-i", "--input", dest="infile",
    help="input file")
  parser.add_option("-o", "--output", dest="outfile",
    help="output file")
  parser.add_option("-f", "--format", dest="format",
    help="output format (tex or html)")

  (options, args) = parser.parse_args()

  if not options.infile or not os.path.isfile(options.infile):
    parser.error("Please enter a valid input file.")
  if not (options.outfile or options.format):
    parser.error("Please enter either an output file or an output format.")

  format = options.format
  if not format:
    format = os.path.splitext(options.outfile)[1].strip(".")
  if format not in ["tex", "html"]:
    parser.error("Please choose a valid output format (tex or html).")

  outfile = options.outfile
  if not outfile:
    outfile = os.path.splitext(options.infile)[0] + "." + format

  try:
    input = open(options.infile, "r").read()
  except IOError:
    parser.error("Unable to open the file: %s" % options.infile)

  if format == "html":
    output = texml_to_html(input)
  elif format == "tex":
    output = texml_to_tex(input)

  try:
    open(outfile, "w").write(output)
    print("Created %s" % outfile)
  except IOError:
    register_error("Unable to write to file: %s" % outfile)
